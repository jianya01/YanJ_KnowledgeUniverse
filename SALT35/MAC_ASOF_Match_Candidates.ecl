/*
This macro uses the history file generated by the internal linking process to expand the match candidates
to construct a new set of match candidates that can answer the question: 'what would be fetched at any point
in time'.
Parameters:
	- infile: the file to be patched
  - in_did_field
	- in_rid_field
	- in_dt_early
	- in_dt_late
	- co_collapses: the change history file (record: old_did | rid | new_did | date of change)
	- co_old_did
	- co_new_did
	- co_rid
	- co_date
Steps:
 1) First project all records such that dt_first_usable is the in_dt_early and the dt_last_usable is blank. 
(For any dids that never collapsed - this is all we need)
 2) Sort the changes file by rid and change date (descending) and number the changes per rid (using ITERATE)- this tells us how many modifications occurred to each rid
 3) Join the output of 2 to the changes file with sequenceNum = current loop iteration number (first time will be the first change for this rid (if any), going backwards in time) by rid and did = co_new_did - left outer (this tells you that 
this was when this rid was assigned that did). Set the in_dt_early to the co_date (in the case of a match). NO NEW RECORDS 
in this step.
 4) Now repeat the join performed in 3 but this time inner. In the transform change the in_did_field to 
the co_old_did and set the dt_last_usable to the co_date and the dt_first_usable to the earliest date on the record (in_dt_early). This generates NEW records.
 5) We now need to effectively repeat step 3 using the output from step 4. This will clip the dt_first_usable 
of the parent records to when the rid/did association was created
 6) We now repeat step 4 using the output of step 5
etc.
The number of loops required is the maximum number of changes to any rid recorded in the match history file
*/
EXPORT MAC_ASOF_Match_Candidates(infile, in_did_field, in_rid_field, in_dt_early, in_dt_late, co_collapses, co_old_did, co_new_did, co_rid, co_date) := FUNCTIONMACRO
  NewCandidatesRec := RECORD
		infile; 
		TYPEOF(infile.in_dt_early) dt_first_usable;
		TYPEOF(infile.in_dt_early) dt_last_usable;
		UNSIGNED2 level;
  END;
	NewCandidatesRec init_usables(infile le) := TRANSFORM
	  SELF.dt_first_usable := le.in_dt_early;
		SELF.dt_last_usable := (TYPEOF(le.in_dt_late))'';
		SELF.level := 0;
		SELF := le;
	END;
	infile1 := DISTRIBUTE(PROJECT(infile,init_usables(LEFT)), in_rid_field);
	
	Layout_numbered := RECORD
		RECORDOF(co_collapses);
		UNSIGNED4 sequenceNum := 0;
	END;
	co_collapses_numbered := ITERATE(SORT(DISTRIBUTE(PROJECT(co_collapses, Layout_numbered), co_rid), co_rid, -co_date, LOCAL),
	                                 TRANSFORM(Layout_numbered,
																	           SELF.sequenceNum := IF(LEFT.co_rid = RIGHT.co_rid, LEFT.sequenceNum + 1, 1);
																						 SELF := RIGHT),
																	 LOCAL);
	                                 
	
	loopBody(DATASET( NewCandidatesRec) ds, UNSIGNED2 Iteration) := FUNCTION
	   ds1 := JOIN(ds,co_collapses_numbered(sequenceNum = Iteration),LEFT.in_rid_field=RIGHT.co_rid AND LEFT.in_did_field = RIGHT.co_new_did AND LEFT.level = Iteration - 1,
							TRANSFORM(NewCandidatesRec,
								SELF.dt_first_usable:=IF(RIGHT.co_date<>(TYPEOF(RIGHT.co_date))'',RIGHT.co_date,LEFT.dt_first_usable),
								SELF.level:=IF(RIGHT.co_date<>(TYPEOF(RIGHT.co_date))'',Iteration - 1,LEFT.level),
								SELF:=LEFT;)
						,LEFT OUTER
						,LOCAL);
	   patch := JOIN(ds1(level=Iteration - 1),co_collapses_numbered(sequenceNum = Iteration),LEFT.in_rid_field=RIGHT.co_rid AND LEFT.in_did_field = RIGHT.co_new_did,
								TRANSFORM(NewCandidatesRec,
									SELF.level:=Iteration,
									SELF.in_did_field:=RIGHT.co_old_did,
									SELF.dt_last_usable:=RIGHT.co_date,
									SELF.dt_first_usable:=LEFT.in_dt_early,
									SELF:=LEFT;),
									LOCAL);
		
		RETURN ds1+patch;
  END;
	
	RETURN LOOP(infile1, MAX(co_collapses_numbered, sequenceNum), loopBody(ROWS(LEFT),COUNTER));
ENDMACRO;

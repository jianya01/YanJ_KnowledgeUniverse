/*
This macro uses the history file generated by the internal linking process to expand the match candidates
to construct a new set of match candidates that can answer the question: 'what would be fetched at any point
in time'.
Parameters:
	- infile: the file to be patched
  - in_did_field
	- in_rid_field
	- in_dt_seen_first
	- in_dt_seen_last
	- co_collapses: the change history file (record: old_did | rid | new_did | date of change)
	- co_old_did
	- co_new_did
	- co_rid
	- co_date
  - in_dt_usable_first
  - in_dt_usable_last
Steps:
 1) First project all records such that dt_first_usable is the in_dt_seen_first and the dt_last_usable is blank. 
(For any dids that never collapsed/changed - this is all we need)
However, if effectivedates have been defined in the file (in_dt_usable_first,in_dt_usable_last), they are used instead.
 2) Sort the changes file by rid and change date (descending) and number the changes per rid (using ITERATE)- this tells us how many modifications occurred to each rid
 3) Join the output of 2 to the changes file with sequenceNum = current loop iteration number (first time will be the first change for this rid (if any), going backwards in time) by rid and did = co_new_did - left outer (this tells you that 
this was when this rid was assigned that did). Set the dt_first_usable (or in_dt_usable_first, if supplied) to the co_date (in the case of a match). NO NEW RECORDS 
in this step.
 4) Now repeat the join performed in 3 but this time inner. In the transform change the in_did_field to 
the co_old_did and set the dt_last_usable (or in_dt_usable_last, if supplied) to the co_date (minus one month/day/second, depending on date format of YYYYMM/YYYYMMDD/YYYYMMDDHHMMSS
so that the rid does not have two did associations on the same date)
and the dt_first_usable (or in_dt_usable_first, if supplied) to the earliest date on the record (earliest_first). This generates NEW records.
 5) We now need to effectively repeat step 3 using the output from step 4. This will clip the dt_first_usable (or in_dt_usable_first) 
of the parent records to when the rid/did association was created
 6) We now repeat step 4 using the output of step 5
etc.
The number of loops required is the maximum number of changes to any rid recorded in the match history file
Note that the format of co_date will be expanded (dangerous- hopefully we don't store changes at a lower resolution than in_dt_seen_first/in_dt_seen_last- we can miss applying changes
in this case if there are multiple changes for the same in_rid_field/co_date)
or truncated to match the date format of in_dt_seen_first/in_dt_seen_last (also dangerous because we'd be muting intermediate changes within a day,
but this may be acceptable)
*/
EXPORT MAC_ASOF_Match_Candidates(infile, in_did_field, in_rid_field, in_dt_seen_first, in_dt_seen_last, co_collapses, co_old_did, co_new_did, co_rid, co_date, in_dt_usable_first='',in_dt_usable_last='') := FUNCTIONMACRO
	IMPORT STD;
  NewCandidatesRec := RECORD
		infile; 
#IF (#TEXT(in_dt_usable_first) = '' )		
		TYPEOF(infile.in_dt_seen_first) dt_first_usable;
#END		
#IF (#TEXT(in_dt_usable_last) = '' )		
		TYPEOF(infile.in_dt_seen_first) dt_last_usable;
#END		
		TYPEOF(infile.in_dt_seen_first) earliest_first;
		UNSIGNED2 level;
  END;
	NewCandidatesRec init_usables(infile le) := TRANSFORM
#IF (#TEXT(in_dt_usable_first) = '' )			
	  SELF.dt_first_usable := le.in_dt_seen_first;
		SELF.earliest_first := le.in_dt_seen_first;
#ELSE
	  SELF.in_dt_usable_first := le.in_dt_usable_first;
		SELF.earliest_first := le.in_dt_usable_first;
#END		
#IF (#TEXT(in_dt_usable_last) = '' )			
		SELF.dt_last_usable := (TYPEOF(le.in_dt_seen_last))'';
#ELSE
	  SELF.in_dt_usable_last := le.in_dt_usable_last;
#END		
		SELF.level := 0;
		SELF := le;
	END;
	infile1 := DISTRIBUTE(PROJECT(infile,init_usables(LEFT)), in_rid_field);
	
	Layout_numbered := RECORD
		RECORDOF(co_collapses);
		UNSIGNED4 sequenceNum := 0;
	END;
	co_collapses_numbered := ITERATE(SORT(DISTRIBUTE(PROJECT(co_collapses, Layout_numbered), co_rid), co_rid, -co_date, LOCAL),
	                                 TRANSFORM(Layout_numbered,
																	           SELF.sequenceNum := IF(LEFT.co_rid = RIGHT.co_rid, LEFT.sequenceNum + 1, 1);
																						 SELF := RIGHT),
																	 LOCAL);
	
	// get date types for history and stored dates so that expanded dt_first_usable and dt_last_usable will match the
	// date type of in_dt_seen_first and in_dt_seen_last from infile
	isYYYYMMDDHHMMSS(STRING inDate) := LENGTH(inDate) = 14;
	isYYYYMMDD(STRING inDate) := LENGTH(inDate) = 8;
	isYYYYMM(STRING inDate) := LENGTH(inDate) = 6;
	
	infileSampleEarlyDate := (UNSIGNED6)(infile(in_dt_seen_first > 0)[1].in_dt_seen_first);
	infileSampleLateDate  := (UNSIGNED6)(infile(in_dt_seen_last > 0)[1].in_dt_seen_last);
	collapseSampleDate    := (UNSIGNED6)(co_collapses(co_date > 0)[1].co_date);
	infileSampleDate      := MAP(infileSampleEarlyDate > 0	=> infileSampleEarlyDate,
	                             infileSampleLateDate > 0		=> infileSampleLateDate,
															 collapseSampleDate);
	
	infileDateStr := (STRING)infileSampleDate;
	infileDateIsYYYYMMDDHHMMSS 	:= isYYYYMMDDHHMMSS(infileDateStr);
	infileDateIsYYYYMMDD 				:= isYYYYMMDD(infileDateStr);
	infileDateIsYYYYMM 					:= isYYYYMM(infileDateStr);
	
	collapseDateStr := (STRING)collapseSampleDate;
	collapseDateIsYYYYMMDDHHMMSS := isYYYYMMDDHHMMSS(collapseDateStr);
	collapseDateIsYYYYMMDD 			 := isYYYYMMDD(collapseDateStr);
	collapseDateIsYYYYMM 				 := isYYYYMM(collapseDateStr);
	
	// function to convert collapse date to same date format as in_dt_seen_first/in_dt_seen_last when setting start or end dates
	getDate(UNSIGNED6 collapseDateIn, BOOLEAN isEnd) := FUNCTION
		IMPORT STD;
		
		collapseDateInStr := (STRING)collapseDateIn;
		collapseDateInYr 			:= IF(collapseDateIsYYYYMMDDHHMMSS OR collapseDateIsYYYYMMDD OR collapseDateIsYYYYMM, (INTEGER2)(collapseDateInStr[1..4]), 1970);
		collapseDateInMonth   := IF(collapseDateIsYYYYMMDDHHMMSS OR collapseDateIsYYYYMMDD OR collapseDateIsYYYYMM, (UNSIGNED1)(collapseDateInStr[5..6]), 1);
		collapseDateInDay   	:= IF(collapseDateIsYYYYMMDDHHMMSS OR collapseDateIsYYYYMMDD, (UNSIGNED1)(collapseDateInStr[7..8]), 1);
		collapseDateInHr   		:= IF(collapseDateIsYYYYMMDDHHMMSS, (UNSIGNED1)(collapseDateInStr[9..10]), 0);
		collapseDateInMin	 		:= IF(collapseDateIsYYYYMMDDHHMMSS, (UNSIGNED1)(collapseDateInStr[11..12]), 0);
		collapseDateInSec	 		:= IF(collapseDateIsYYYYMMDDHHMMSS, (UNSIGNED1)(collapseDateInStr[13..14]), 0);
		
		dateSecs := STD.Date.SecondsFromParts(collapseDateInYr, collapseDateInMonth, collapseDateInDay, collapseDateInHr, collapseDateInMin, collapseDateInSec);
		dateMinusSec := DATASET([STD.Date.CreateDateTimeFromSeconds(dateSecs - 1)])[1];
		dateMinusDay := DATASET([STD.Date.CreateDateTimeFromSeconds(dateSecs - 86400)])[1];
		dateMinusMonth := IF(collapseDateInMonth = 1, (collapseDateInYr-1)*100 + 12, (collapseDateInYr)*100 + (collapseDateInMonth-1));
		
		useDateEnd		:= MAP(infileDateIsYYYYMMDDHHMMSS => (UNSIGNED6)(dateMinusSec.year*10000000000 + dateMinusSec.month*100000000 + dateMinusSec.day*1000000 + dateMinusSec.hour*10000 + dateMinusSec.minute*100 + dateMinusSec.second),
												 infileDateIsYYYYMMDD 			=> (UNSIGNED4)(dateMinusDay.year*10000 + dateMinusDay.month*100 + dateMinusDay.day),
										     infileDateIsYYYYMM   			=> dateMinusMonth,
										     0);
	  useDateStart	:= MAP(infileDateIsYYYYMMDDHHMMSS => (UNSIGNED6)(collapseDateInYr*10000000000 + collapseDateInMonth*100000000 + collapseDateInDay*1000000 + collapseDateInHr*10000 + collapseDateInMin*100 + collapseDateInSec),
												 infileDateIsYYYYMMDD 			=> (UNSIGNED4)(collapseDateInYr*10000 + collapseDateInMonth*100 + collapseDateInDay),
										     infileDateIsYYYYMM   			=> (UNSIGNED4)(collapseDateInYr*100 + collapseDateInMonth),
										     0);
		useDate := IF(isEnd, useDateEnd, useDateStart);
		RETURN (TYPEOF(infile.in_dt_seen_first))useDate;
	END;
	
	loopBody(DATASET( NewCandidatesRec) ds, UNSIGNED2 Iteration) := FUNCTION
	   ds1 := JOIN(ds,co_collapses_numbered(sequenceNum = Iteration),LEFT.in_rid_field=RIGHT.co_rid AND LEFT.in_did_field = RIGHT.co_new_did AND LEFT.level = Iteration - 1,
							TRANSFORM(NewCandidatesRec,
#IF (#TEXT(in_dt_usable_first) = '' )							
								SELF.dt_first_usable:=IF(RIGHT.co_date<>(TYPEOF(RIGHT.co_date))'',getDate(RIGHT.co_date, FALSE),LEFT.dt_first_usable),
#ELSE
								SELF.in_dt_usable_first:=IF(RIGHT.co_date<>(TYPEOF(RIGHT.co_date))'',getDate(RIGHT.co_date, FALSE),LEFT.in_dt_usable_first),
#END								
								SELF.level:=IF(RIGHT.co_date<>(TYPEOF(RIGHT.co_date))'',Iteration - 1,LEFT.level),
								SELF:=LEFT;)
						,LEFT OUTER
						,LOCAL);
	   patch := JOIN(ds1(level=Iteration - 1),co_collapses_numbered(sequenceNum = Iteration),LEFT.in_rid_field=RIGHT.co_rid AND LEFT.in_did_field = RIGHT.co_new_did,
								TRANSFORM(NewCandidatesRec,
									SELF.level:=Iteration,
									SELF.in_did_field:=RIGHT.co_old_did,
#IF (#TEXT(in_dt_usable_last) = '' )											
									SELF.dt_last_usable:=getDate(RIGHT.co_date, TRUE),
#ELSE
									SELF.in_dt_usable_last:=getDate(RIGHT.co_date, TRUE),
#END									
#IF (#TEXT(in_dt_usable_first) = '' )										
									SELF.dt_first_usable:=LEFT.earliest_first,
#ELSE								
									SELF.in_dt_usable_first:=LEFT.earliest_first,
#END									
									SELF:=LEFT;),
									LOCAL);
		
		RETURN ds1+patch;
  END;
	
	RETURN PROJECT(LOOP(infile1, MAX(co_collapses_numbered, sequenceNum), loopBody(ROWS(LEFT),COUNTER)), RECORDOF(LEFT) - [earliest_first]);
ENDMACRO;
